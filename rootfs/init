#!/bin/sh

set -e
set -x
mount -t devtmpfs none /dev
mount -t sysfs /sys /sys
mount -t proc /proc /proc
mount -t tmpfs -o size=1m,nodev,noexec /tmp /tmp
mount -o remount,ro /

echo 1 > /proc/sys/vm/overcommit_memory

if test -e /sys/class/net/eth0; then
    ip link set eth0 address fe:ff:ff:ff:ff:fe
    ip addr flush eth0
    ip link set eth0 up
    brctl addbr br0
    brctl addif br0 eth0
    ip link set br0 up
else
    echo "No network interface named eth0."
    ls -l /sys/class/net/
fi

domid=$(/bin/xenstore-read "target")
vm_path=$(xenstore-read "/local/domain/$domid/vm")
# convert multiple keys into \n separated arguments, as shell doesn't handle
# NUL well
dm_args=$(xenstore-read $(xenstore-list -p "$vm_path/image/dm-argv"|sort))

target="$(xenstore-read target)"
device_model="device-model/$target"

mkdir /tmp/qmp

mkfifo /tmp/qmp/qemu.in /tmp/qmp/qemu.out

(
  echo '{"execute": "qmp_capabilities"}' | tee /proc/self/fd/2
) >/tmp/qmp/qemu.in &

(
set +x
cat /tmp/qmp/qemu.out | tee /proc/self/fd/2 | \
while IFS= read -r line; do
    if [ $(echo "\\${line}" | grep -cim1 '"event": "DEVICE_DELETED", "data": {"device": "nic0",') -eq 1 ]; then
        /etc/qemu-ifdown
    fi
done
) &

(
set +x
if [ $(echo "$dm_args" | grep -cim1 "ifname=") -eq 1 ]; then
    VIFNAME=$(echo "$dm_args" | sed -n -e 's/^.*ifname=//p' | sed -n -e 's/,.*$//p')
    while true; do
        if [ $(ip link | grep -cim1 "$VIFNAME") -eq 1 ]; then
            break
        fi
        sleep 0.1
    done
    /etc/qemu-ifup "$VIFNAME"
fi
) &

(
set +x
# Clear kernel log buffer to avoid leaking kaslr layout information
# Messages are still written to xen console
echo "Clearing kmsg buffer..." > /dev/kmsg
while read -r line; do
    if [ $(echo "$line" | grep -cim1 "Clearing kmsg buffer...") -eq 1 ]; then
        break
    fi
done < /proc/kmsg
) &

# setup FD 3 and 4 for migration stream (incoming, outgoing), actual qemu
# options are controlled by the toolstack
if exec 118</dev/hvc2; then
    stty raw -echo -echoctl <&118
fi
if exec 119>/dev/hvc1; then
    stty raw -echo -echoctl <&119
fi

dm_args="$( echo "$dm_args" | sed 's/$STUBDOM_RESTORE_INCOMING_ARG/fd:118/' )"

# run swtpm
mkdir /tmp/mytpm1
# create 1M image
head -c 100000 /dev/zero > /tmp/test.img
swtpm socket --tpmstate dir=/tmp/mytpm1 --ctrl type=unixio,path=/tmp/mytpm1/swtpm-sock --log level=5 &

sleep 3
# $dm_args is separated with \n to allow for spaces in arguments.
IFS=$'\n'
set -f
qemu
-chardev pipe,path=/tmp/qmp/qemu,id=m -mon chardev=m,mode=control \
-chardev socket,server,nowait,path=/tmp/qemu.qmp,id=m2 -mon chardev=m2,mode=control \
-chardev socket,id=chrtpm,path=/tmp/mytpm1/swtpm-sock \
-tpmdev emulator,id=tpm0,chardev=chrtpm \
-device tpm-tis,tpmdev=tpm0 \
    $dm_args &
set +f
unset IFS

qemu_pid=$!

qmp_hello=$'{"execute":"qmp_capabilities","id":1}\r\n'
qmp_addfd=$'{"execute":"add-fd", "arguments": { "fdset-id": 1 }, "id":42 }\r\n'

while [ ! -e /tmp/qemu.qmp ]; do sleep 0.1; done
add-fd /tmp/qemu.qmp /dev/fd/119 "$qmp_hello$qmp_addfd" "42"

exec 118<&-
exec 119>&-


# FIXME: this assume dom0 as toolstack domain
vchan-socket-proxy 0 $device_model/qmp-vchan /tmp/qemu.qmp &

while true; do
    printf '==== Press enter for shell ====\n'
    read
    setsid /bin/cttyhack /bin/sh
done
